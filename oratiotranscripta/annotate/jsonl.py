"""Helpers for generating JSONL exports with stable identifiers."""

from __future__ import annotations

from typing import Any, Dict, Iterator, List, Mapping, MutableMapping, Optional, Sequence


def _normalise_segment_id(value: Any) -> Any:
    if isinstance(value, (int, float)):
        return int(value)
    text = str(value).strip()
    if text.isdigit():
        return int(text)
    return text


def _normalise_segment(segment: Mapping[str, Any]) -> Dict[str, Any]:
    if isinstance(segment, MutableMapping):
        return dict(segment)
    return {"text": str(segment)}


def _sort_key(item: Dict[str, Any]) -> tuple:
    start = item.get("start")
    if isinstance(start, (int, float)):
        return (0, float(start), item["_source_index"])
    return (1, item["_source_index"])


def iter_records(
    segments: Sequence[Mapping[str, Any]],
    *,
    metadata: Optional[Mapping[str, Any]] = None,
    raw_transcription: Optional[Mapping[str, Any]] = None,
) -> Iterator[Dict[str, Any]]:
    """Yield compact JSONL records ordered by time with stable IDs.

    The ``metadata`` and ``raw_transcription`` parameters are preserved for
    backwards compatibility but no longer influence the emitted records. All
    contextual information is expected to be persisted in the accompanying
    manifest generated by the CLI.
    """

    normalised: List[Dict[str, Any]] = []
    for index, segment in enumerate(segments, start=1):
        payload = _normalise_segment(segment)
        payload["_source_index"] = index
        normalised.append(payload)

    normalised.sort(key=_sort_key)

    for position, segment in enumerate(normalised, start=1):
        segment.pop("_source_index", None)
        record = _build_compact_record(segment, position)
        if record:
            yield record


def _build_compact_record(segment: Dict[str, Any], position: int) -> Dict[str, Any]:
    record: Dict[str, Any] = {}

    utt_id = segment.pop("utt_id", None)
    if not isinstance(utt_id, str) or not utt_id.strip():
        utt_id = f"utt-{position:04d}"
    record["utt_id"] = utt_id

    start = _coerce_number(segment.pop("start", None))
    end = _coerce_number(segment.pop("end", None))
    duration = _coerce_number(segment.pop("duration_sec", None))
    if duration is None and None not in (start, end):
        computed = float(end) - float(start)  # type: ignore[operator]
        duration = max(computed, 0.0)
    if start is not None:
        record["start"] = start
    if end is not None:
        record["end"] = end
    if duration is not None:
        record["duration_sec"] = duration

    text = segment.pop("text", "")
    record["text"] = str(text) if not isinstance(text, str) else text

    speaker = _extract_speaker(segment)
    if speaker:
        record["speaker"] = speaker

    orig = _build_orig(segment)
    if orig:
        record["orig"] = orig

    return record


def _coerce_number(value: Any) -> Optional[float]:
    if isinstance(value, (int, float)):
        return float(value)
    return None


def _extract_speaker(segment: Dict[str, Any]) -> Optional[Dict[str, Optional[str]]]:
    speaker_info = segment.pop("speaker", None)
    speaker_id: Optional[str] = None
    speaker_name: Optional[str] = None

    if isinstance(speaker_info, Mapping):
        speaker_id = _coerce_str(
            speaker_info.get("id")
            or speaker_info.get("speaker_id")
            or speaker_info.get("spk_id")
        )
        for key in ("name", "label", "display", "text"):
            candidate = speaker_info.get(key)
            if candidate:
                speaker_name = _coerce_str(candidate)
                if speaker_name:
                    break
        if speaker_name is None and speaker_id:
            speaker_name = speaker_id
    elif speaker_info not in (None, ""):
        speaker_name = _coerce_str(speaker_info)

    speaker_id = speaker_id or _coerce_str(segment.pop("speaker_id", None))
    speaker_name = speaker_name or _coerce_str(segment.pop("speaker_name", None))
    if speaker_name is None:
        fallback_label = segment.pop("speaker_label", None)
        speaker_name = _coerce_str(fallback_label)
    if speaker_id is None:
        speaker_id = _coerce_str(segment.pop("spk_id", None))

    if speaker_id is None and speaker_name is None:
        return None

    return {"id": speaker_id, "name": speaker_name}


def _coerce_str(value: Any) -> Optional[str]:
    if value is None:
        return None
    if isinstance(value, str):
        text = value.strip()
        return text or None
    text = str(value).strip()
    return text or None


def _build_orig(segment: Dict[str, Any]) -> Optional[Dict[str, List[Any]]]:
    orig: Dict[str, List[Any]] = {}
    existing_orig = segment.pop("orig", None)
    if isinstance(existing_orig, Mapping):
        segment_ids = _collect_identifier_sequence(existing_orig.get("segment_ids"))
        spk_ids = _collect_identifier_sequence(
            existing_orig.get("spk_ids") or existing_orig.get("speaker_ids")
        )
        if segment_ids:
            orig["segment_ids"] = segment_ids
        if spk_ids:
            orig["spk_ids"] = spk_ids

    segment_ids = _collect_identifier_sequence(segment.pop("segments", None))
    if segment_ids:
        orig["segment_ids"] = segment_ids

    spk_ids = _collect_identifier_sequence(segment.pop("spk_ids", None))
    if spk_ids:
        orig["spk_ids"] = spk_ids

    return orig or None


def _collect_identifier_sequence(value: Any) -> List[Any]:
    identifiers: List[Any] = []
    if isinstance(value, Sequence) and not isinstance(value, (str, bytes)):
        for item in value:
            normalised = _normalise_segment_id(item)
            if normalised is None:
                continue
            if normalised not in identifiers:
                identifiers.append(normalised)
    elif value not in (None, ""):
        normalised = _normalise_segment_id(value)
        if normalised is not None:
            identifiers.append(normalised)
    return identifiers


def build_records(
    segments: Sequence[Mapping[str, Any]],
    *,
    metadata: Optional[Mapping[str, Any]] = None,
    raw_transcription: Optional[Mapping[str, Any]] = None,
) -> List[Dict[str, Any]]:
    """Return a list with all JSONL records."""

    return list(
        iter_records(
            segments,
            metadata=metadata,
            raw_transcription=raw_transcription,
        )
    )


__all__ = ["build_records", "iter_records"]

